<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Ocean's Blog]]></title>
  <link href="http://blog.nwy.me/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.nwy.me/"/>
  <updated>2013-04-26T10:31:36+08:00</updated>
  <id>http://blog.nwy.me/</id>
  <author>
    <name><![CDATA[Ocean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RAM Host的KVM VPS安装CentOS6.2]]></title>
    <link href="http://blog.nwy.me/blog/2012/06/07/ram-host-kvm-the-vps-installation-centos6-2/"/>
    <updated>2012-06-07T00:00:00+08:00</updated>
    <id>http://blog.nwy.me/blog/2012/06/07/ram-host-kvm-the-vps-installation-centos6-2</id>
    <content type="html"><![CDATA[<p>RAM Host的VPS由于站长也是Linux技术大牛，做过优化，即使低端配置性能也不错，所以销量一直很好，加上站长不超售的原则，往往一放出就告罄，上周末终于抢到一个。购买的时候因为开着代理，被Ram Host的订单系统检测到当作风险订单处理了，最后发ticket和站长解释了一番天朝的网络环境才订单才得以通过。</p>

<p>这次买的是RAM Host的Premium West Coast Los Angeles Virtual Dedicated Server的Standard VPS，512MB内存，这个机房的VPS都是KVM的，没有部署站长优化过得系统，需要先在VPS管理面板里选择引导安装系统的镜像ISO。</p>

<p><img src="http://nwy.me/wp-content/uploads/2012/06/%E9%80%89%E5%8C%BA_002.png" alt="系统选择" /></p>

<p>VNC连接主机后进Console，需要注意的是VPS管理面板里VM Console页面给的连接端口是随机的。</p>

<p><img src="http://nwy.me/wp-content/uploads/2012/06/QEMU-oceannan-%E5%9C%A8-2012-06-07-003459-%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="QEMU (oceannan) 在 2012-06-07 00:34:59 的屏幕截图" /></p>

<p>这部分就不一一截图了，一路空格加回车，然后重启。</p>

<p>登录系统后需要先配置ip，修改对应网卡的网关的配置文件，</p>

<p><code>vi /etc/sysconfig/Network </code></p>

<p>设置本机连接的网关的IP地址,在VPS管理面板里有给出，加入一行：</p>

<p><code>GATEWAY=10.0.0.1</code></p>

<p>修改对应网卡的IP地址的配置文件：</p>

<p><code>vi /etc/sysconfig/Network-scripts/ifcfg-eth0</code></p>

<p>修改以下内容:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">DEVICE</span><span class="o">=</span>eth0 <span class="c">#描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0</span>
</span><span class='line'><span class="nv">BOOTPROTO</span><span class="o">=</span>static <span class="c">#设置网卡获得ip地址的方式，可能的选项为static，dhcp或bootp，分别对应静态指定的 ip地址，通过dhcp协议获得的ip地址，通过bootp协议获得的ip地址</span>
</span><span class='line'><span class="nv">BROADCAST</span><span class="o">=</span>192.168.0.255 <span class="c">#对应的子网广播地址</span>
</span><span class='line'><span class="nv">HWADDR</span><span class="o">=</span>00:03:E8:04:D8:B3 <span class="c">#对应的网卡物理地址</span>
</span><span class='line'><span class="nv">IPADDR</span><span class="o">=</span>192.168.1.2 <span class="c">#如果设置网卡获得 ip地址的方式为静态指定，此字段就指定了网卡对应的ip地址</span>
</span><span class='line'><span class="nv">NETMASK</span><span class="o">=</span>255.255.255.0 <span class="c">#网卡对应的网络掩码</span>
</span><span class='line'><span class="nv">Network</span><span class="o">=</span>192.168.1.0 <span class="c">#网卡对应的网络地址</span>
</span><span class='line'><span class="nv">IPV6INIT</span><span class="o">=</span>no
</span><span class='line'><span class="nv">IPV6_AUTOCONF</span><span class="o">=</span>no
</span><span class='line'><span class="nv">ONBOOT</span><span class="o">=</span>yes <span class="c">#系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
重启网络，使刚才的设置生效。</p>

<p><code>service Network restart</code></p>

<p>至此Centos6.2就安装完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下ext4分区格式恢复删除文件]]></title>
    <link href="http://blog.nwy.me/blog/2011/11/27/ext4-partition-under-linux-format-to-recover-deleted-files/"/>
    <updated>2011-11-27T00:00:00+08:00</updated>
    <id>http://blog.nwy.me/blog/2011/11/27/ext4-partition-under-linux-format-to-recover-deleted-files</id>
    <content type="html"><![CDATA[<p>作为键盘党，下午在用键盘选择文件夹的时候，没有盯对文件夹就shift+delete删除了一个重要文件夹，之前就发生过丢失数据的悲剧，于是给笔记本增加了一块硬盘，重要数据定时同步到光驱位硬盘，不过今天误删除的文件夹还没同步到光驱位硬盘。在ext2分区格式下有许多文件恢复软件，但是这些软件都不支持ext4，或兼容的不太好，如testdisk，虽然可以看到误删的文件但是恢复出来的文件是损坏的。最后通过一番搜索找到了一款支持ext4的的恢复软件extundelete。</p>

<p>安装extundelete，可以去软件主页http://extundelete.sourceforge.net下载编译，或者从服务器获取，不同的发行版的安装方法不同，这里不再详述。</p>

<p>extundelete --help 查看软件帮助</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Usage: extundelete <span class="o">[</span>options<span class="o">]</span> <span class="o">[</span>--<span class="o">]</span> device-file
</span><span class='line'>Options:
</span><span class='line'>  --version, -<span class="o">[</span>vV<span class="o">]</span>       Print version and <span class="nb">exit </span>successfully.
</span><span class='line'>  --help,                Print this <span class="nb">help </span>and <span class="nb">exit </span>successfully.
</span><span class='line'>  --superblock           Print contents of superblock in addition to the rest.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                     If no action is specified <span class="k">then </span>this option is implied.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  --journal              Show content of journal.
</span><span class='line'>  --after dtime          Only process entries deleted on or after <span class="s1">&#39;dtime&#39;</span>.
</span><span class='line'>  --before dtime         Only process entries deleted before <span class="s1">&#39;dtime&#39;</span>.
</span><span class='line'>Actions:
</span><span class='line'>  --inode ino            Show info on inode <span class="s1">&#39;ino&#39;</span>.
</span><span class='line'>  --block blk            Show info on block <span class="s1">&#39;blk&#39;</span>.
</span><span class='line'>  --restore-inode ino<span class="o">[</span>,ino,...<span class="o">]</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                     Restore the file<span class="o">(</span>s<span class="o">)</span> with known inode number <span class="s1">&#39;ino&#39;</span>.
</span><span class='line'>                     The restored files are created in ./RESTORED_FILES
</span><span class='line'>                     with their inode number as extension <span class="o">(</span>ie, file.12345<span class="o">)</span>.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  --restore-file <span class="s1">&#39;path&#39;</span>  Will restore file <span class="s1">&#39;path&#39;</span>. <span class="s1">&#39;path&#39;</span> is relative to root&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                     of the partition and does not start with a <span class="s1">&#39;/&#39;</span> <span class="o">(</span>it
</span><span class='line'>                     must be one of the paths returned by --dump-names<span class="o">)</span>.
</span><span class='line'>                     The restored file is created in the current
</span><span class='line'>                     directory as <span class="s1">&#39;RECOVERED_FILES/path&#39;</span>.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  --restore-files <span class="s1">&#39;path&#39;</span> Will restore files which are listed in the file <span class="s1">&#39;path&#39;</span>.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                     Each filename should be in the same format as an option
</span><span class='line'>                     to --restore-file, and there should be one per line.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  --restore-all          Attempts to restore everything.
</span><span class='line'>  -j journal             Reads an external journal from the named file.
</span><span class='line'>  -b blocknumber         Uses the backup superblock at blocknumber when opening&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                     the file system.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  -B blocksize           Uses blocksize as the block size when opening the file&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                     system.  The number should be the number of bytes.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>软件支持根据时间，文件路径，inode恢复删除的文件，这里指定文件路径恢复误删文件</p>

<p>根据文件路径恢复也有多种方式，如下：</p>

<p>恢复/dev/sda3里一个被误删除的文件</p>

<p><code>
extundelete /dev/sda3 --restore-file /an/important/file
</code></p>

<p>恢复/dev/sda3里一个被误删除的文件夹</p>

<p><code>
extundelete /dev/sda3 --restore-directory /an/important
</code></p>

<p>恢复/dev/sda3里所有被删除的东西</p>

<p><code>
extundelete /dev/sda3 --restore-all
</code></p>

<p>extundelete恢复误删除的文件不需要进入live环境，也不需要umount误删文件所在分区，运行命令后会在你运行命令的目录下产生一个RECOVERED_FILES/的目录，恢复的文件会按照原来的路径创建在该路径下面，所以做恢复操作的时候一定要把终端路径切换到其他分区下，不能在当前误删文件所在分区操作，否则恢复出来的文件会覆盖误删除的文件，导致恢复出来的部分或全部文件损坏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arch Linux下webOS开发平台的搭建]]></title>
    <link href="http://blog.nwy.me/blog/2011/09/19/archlinux-development-platform-to-build-next-webos/"/>
    <updated>2011-09-19T00:00:00+08:00</updated>
    <id>http://blog.nwy.me/blog/2011/09/19/archlinux-development-platform-to-build-next-webos</id>
    <content type="html"><![CDATA[<p>作为一个02年开始使用palm的资深palm用户，对palm有着根深蒂固的感情。在palm的陪伴下，经历了高中大学的学生时代，步入社会，开始工作。palm曾经的辉煌也一去不复返，在这个物质，浮躁，快速化的世界，palm系统的单线程，简洁的特性在全球网络化的时代逐渐淡出人们的视线，随后palm公司发布了webOS，被惠普公司收购。发现跑题已经是我写技术文章的特色之一了，言归正传。</p>

<p>在webOS的开发网站上，针对linux环境只提供了ubuntu发行版的驱动和SDK，而我在几个月前从ubuntu阵营转向简洁轻巧的archlinux阵营。两者采用不通的包管理机制。为了让archlinux识别palm pre，需要先安装设备驱动，既然官方没有不提供，尝试用deb2targz转换失败后，只好自己动手解开deb格式的驱动，通过谷歌了解了一下deb的制作方法后，大概理解了deb的安装方式，解压出来的deb包目录下，将data目录的文件按照文件路径名复制到archlinux对应的目录下，control目录下的postinst文件是安装脚本，如下</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;!/bin/sh&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;#&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;kill and remove OLD novacomd upstart&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;#
</span><span class='line'><span class="k">if</span> <span class="o">[</span> -e /etc/event.d/novacomd <span class="o">]</span> ; <span class="k">then</span>
</span><span class='line'>stop novacomd
</span><span class='line'>rm -f /etc/event.d/novacomd
</span><span class='line'><span class="k">fi</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;#&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;remove novacomd from /usr/local/bin&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;#
</span><span class='line'><span class="k">if</span> <span class="o">[</span> -e /usr/local/bin/novacomd <span class="o">]</span> ; <span class="k">then</span>
</span><span class='line'>rm -f /usr/local/bin/novacomd
</span><span class='line'><span class="k">fi</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;#&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;check <span class="k">for </span>new upstart&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;#
</span><span class='line'><span class="k">if</span> <span class="o">[</span> -e /etc/init/rc.conf <span class="o">]</span> ; <span class="k">then</span>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> -e /etc/init/palm-novacomd.conf <span class="o">]</span> ; <span class="k">then</span>
</span><span class='line'>rm -f /etc/init/palm-novacomd.conf
</span><span class='line'><span class="k">fi</span>
</span><span class='line'>cp -a  /opt/Palm/novacom/scripts/novacomd-conf    /etc/init/palm-novacomd.conf
</span><span class='line'><span class="k">elif</span> <span class="o">[</span> -e /etc/event.d <span class="o">]</span> ; <span class="k">then</span>
</span><span class='line'>ln -fs /opt/Palm/novacom/scripts/novacomd-upstart /etc/event.d/palm-novacomd
</span><span class='line'><span class="k">fi</span>
</span><span class='line'><span class="c">#&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;<span class="o">(</span>re<span class="o">)</span>start novacomd&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;#
</span><span class='line'>stop palm-novacomd <span class="o">||</span> <span class="nb">true</span>
</span><span class='line'>killall -v -q novacomd
</span><span class='line'>start palm-novacomd <span class="o">||</span> <span class="nb">true</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>直接运行脚本显然是不行的，archlinux没有/etc/init/和/etc/event.d/目录，/etc/init/实际是指向/etc/rc.d/int.d/的一个符号链接文件，/etc/event.d/是ubuntu特有的upstart机制的核心目录，archlinux的服务可以通过特有的rc.conf启动，也可以通过/etc/init.d/或者/etc/rc.d/下建立脚本创建服务。了解脚本后将novacomd复制到/etc/rc.d/,novacomd.conf复制到/etc/conf.d/做完archlinux下的改动后，在终端里输入
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/etc/rc.d/novacom start&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>提示未找的设备，谷歌一番后在http://www.webos-internals.org/wiki/Accessing_Linux_archlinux 上发现解决方法:"novacomd doesn't work under archlinux , so we have to use ubuntu's libusb. "意想不到的是wiki中给出了一条简便方法，从aur下载网友打包好的novacom驱动，汗，之前怎么没有想到在aur里搜索一下。</p>

<!--more-->


<p>一番折腾后palm pre在archlinux下的驱动搞定了，解压deb驱动包的时候看到过novaterm的文件，运行后登录到手机shell，webOS是linux核心，busybox中带有linux常用命令，于是可以在电脑上查看手机的运行状态了。</p>

<p><img src="http://nwy.me/wp-content/uploads/2011/09/Screenshot-ocean@ocean-laptop.png" alt="Screenshot-ocean@ocean-laptop:~" /></p>

<p>显摆几张手机桌面</p>

<p><img src="http://nwy.me/wp-content/uploads/2011/09/Unknown_2011-19-09_040802.png" alt="Unknown_2011-19-09_040802" />
<img src="http://nwy.me/wp-content/uploads/2011/09/Unknown_2011-19-09_040751.png" alt="Unknown_2011-19-09_040751" />
<img src="http://nwy.me/wp-content/uploads/2011/09/Unknown_2011-19-09_040742.png" alt="Unknown_2011-19-09_040742" /></p>

<p> </p>

<p> </p>

<p>接下来安装webOS的SDK，有了之前的经验，直接从aur搜索网友打包好的sdk，下载安装。</p>

<p>手机平台webOS1.45 SDK截图</p>

<p><img src="http://nwy.me/wp-content/uploads/2011/09/Screenshot-SDK-1.4.5.465-320x480-Running-Oracle-VM-VirtualBox.png" alt="Screenshot-SDK 1.4.5.465 (320x480) [Running] - Oracle VM VirtualBox" /></p>

<p>TouchPad平板 webOS3.0.2 SDk截图</p>

<p><img src="http://nwy.me/wp-content/uploads/2011/09/SDK-3.0.2.652-1024x768-Running-Oracle-VM-VirtualBox_001.png" alt="SDK 3.0.2.652 (1024x768) [Running] - Oracle VM VirtualBox_001" />
<img src="http://nwy.me/wp-content/uploads/2011/09/SDK-3.0.2.652-1024x768-Running-Oracle-VM-VirtualBox_003.png" alt="SDK 3.0.2.652 (1024x768) [Running] - Oracle VM VirtualBox_003" /></p>

<p>至此，archlinux下webOS的开发环境搭建完成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[curl 简单作弊条]]></title>
    <link href="http://blog.nwy.me/blog/2011/06/22/simple-cheat-curl-bar/"/>
    <updated>2011-06-22T00:00:00+08:00</updated>
    <id>http://blog.nwy.me/blog/2011/06/22/simple-cheat-curl-bar</id>
    <content type="html"><![CDATA[<div id="content">
<div class="entry">
<h5>原文出处：<a href="http://liluo.org/2011/05/curl-%E7%AE%80%E5%8D%95%E4%BD%9C%E5%BC%8A%E6%9D%A1/">http://liluo.org/2011/05/curl-%E7%AE%80%E5%8D%95%E4%BD%9C%E5%BC%8A%E6%9D%A1/</a>
</h5>
<h5>1  curl是什么？</h5>
curl 是一款命令行多协议支持的服务器访问工具,可以用它来访问HTTP服务器，就像浏览器一样。当然了，它也是可以通过FTP下载或上传文件，下次再说这块。
<h5>2 基本应用</h5>
<blockquote>curl http://www.douban.com</blockquote>
上面的命令会在屏幕上输出服务器的响应信息，需要headers信息加 -i/--include 参数，只需要headers信息可以使用 -I/--head。

重定向输出：
<blockquote>curl http://www.douban.com > response.html
curl http://www.douban.com | grep 'douban.com'</blockquote>
如果使用管道，默认会有一个进程信息显示出来，可以使用 -s/--silent 来不显示它们：
<blockquote>curl -s http://www.douban.com | grep 'douban.com'</blockquote>
如果想保存服务器返回的内容的话，除了使用 > 重定向到一个文件外，还可以使用 -o/--output 参数指定需要保存到的文件：
<blockquote>curl http://www.douban.com -o response.html</blockquote>
非文本文件也能这样保存：
<blockquote>curl http://img3.douban.com/pics/nav/lg_main_a7.png -o logo.png</blockquote>
原名保存使用 -O/--remote-name 选项：
<blockquote>curl http://img3.douban.com/pics/nav/lg_main_a7.png -O</blockquote>
不过豆瓣的图片有简单的防盗链，所以可能下载不成功 : ( 继续往下看
<h5>
<!--more-->3   发送数据</h5>
GET 方法的请求没什么特殊的，直接在 url 中放上数据就可以了：
<blockquote>curl http://www.douban.com/?name=luo
curl http://www.douban.com/?name=小落</blockquote>
POST 方法的话就需要使用 -d/--data 参数，只要有这个参数，即使值是空字符串，那么出去的就是 POST 方法的访问：
<blockquote>curl -d 'name=luoluo&passwd=*****' http://www.douban.com</blockquote>
<h5>4   头部信息</h5>
先说最常构造的两个 User-Agent 和 Referer ，这两个分别使用 -A/--user-agent 和 -e/--referer 来指定：
<blockquote>curl -A Chrome http://www.douban.com
curl -e http://liluo.org http://www.douban.com</blockquote>
包含这两个头部信息，所有的头部信息参数都可以使用 -H/--header 来设置：
<blockquote>curl -H Referer:http://liluo.org http://www.douban.com
curl -H User-Agent:Chrome -H Accept-Language:zh-cn http://www.douban.com</blockquote>
<h5>5   COOKIE控制</h5>
curl 是可以支持带 cookie 的交互行为的。使用方式是 -D/--dump-header 用于指定一个文件保存获取到的 cookie 信息（实际上包含了整个头部信息）， 然后用 -b/--cookie 指定一文件用于读取保存的 cookie 。
<blockquote>curl http://www.douban.com -D cookie.txt
curl http://www.douban.com -b cookie.txx</blockquote>
-D 保存出来的头部信息就是以纯文本形式存放的，所以，你可以方便地随便修改。
<h5>6   代理和通配符</h5>
6.1   代理设置

使用 -x/--proxy 参数：
<blockquote>curl -x http://web.proxy.url http://www.douban.com</blockquote>
6.2   通配符
<blockquote>curl -O http://www.douban.com/~liluo/screen[1-10].jpg
curl -O http://www.douban.com/~{liluo,luoluo}/[001-201].jpg</blockquote>
反向引用分组：
<blockquote>curl -o #2_#1.jpg http://www.douban.com/~{liluo,luo}/[001-201].jpg</blockquote>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下命令执行顺序]]></title>
    <link href="http://blog.nwy.me/blog/2011/06/22/linux-command-execution-order/"/>
    <updated>2011-06-22T00:00:00+08:00</updated>
    <id>http://blog.nwy.me/blog/2011/06/22/linux-command-execution-order</id>
    <content type="html"><![CDATA[<div><a href="http://doc.linuxpk.com/52705.html">本文来自：Linux宝库 -- http://doc.linuxpk.com/52705.html</a></div>


<p> </p>

<p>在执行某个命令的时候，有时需要依赖于前一个命令是否执行成功。例如，假设你希望将一个目录中的文件全部拷贝到另外一个目录中后，然后删除源目录中的全部文件。在删除之前，你希望能够确信拷贝成功，否则就有可能丢失所有的文件。</p>

<p>在本章中，我们将讨论：</p>

<h1>命令执行控制。</h1>

<h1>命令组合。</h1>

<p>如果希望在成功地执行一个命令之后再执行另一个命令，或者在一个命令失败后再执行另一个命令，&amp;&amp;和||可以完成这样的功能。相应的命令可以是系统命令或shell脚本。</p>

<p>Shell还提供了在当前shell或子shell中执行一组命令的方法，即使用（）和{}。</p>

<h1>6.1 使用&amp;&amp;</h1>

<p>使用&amp;&amp;的一般形式为：</p>

<p>命令1 &amp;&amp; 命令2</p>

<p>这种命令执行方式相当地直接。&amp;&amp;左边的命令（命令1）返回真(即返回0，成功被执行）后，&amp;&amp;右边的命令（命令2）才能够被执行；换句话说，“如果这个命令执行成功&amp;&amp;那么执行这个命令”。</p>

<p>这里有一个使用&amp;&amp;的简单例子：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cp justing.doc justing.bak &amp;amp;&amp;amp; <span class="nb">echo</span> “if you are seeing this <span class="k">then </span>cp was OK”
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h1>if you are seeing this then cp was OK</h1>

<p>在上面的例子中，&amp;&amp;前面的拷贝命令执行成功，所以&amp;&amp;后面的命令（echo命令）被执行。</p>

<p>再看一个更为实用的例子：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>mv /apps/bin /apps/dev/bin &amp;amp;&amp;amp; rm -r /apps/bin　
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的例子中，/apps/bin目录将会被移到/apps/dev/bin目录下，如果它没有被成功执行，就不会删除/apps/bin目录。</p>

<p>在下面的例子中，文件quarter_end.txt首先将被排序并输出到文件quarter.sorted中，只有这一命令执行成功之后，文件quarter.sorted才会被打印出来：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sort quarter_end.txt &gt; quarter.sorted &amp;amp;&amp;amp; lp quarter.sorted
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<!--more-->


<h1>6.2 使用||</h1>

<p>使用||的一般形式为：</p>

<p>命令1 || 命令2</p>

<p>||的作用有一些不同。如果||左边的命令（命令1）未执行成功，那么就执行||右边的命令（命令2）；或者换句话说，“如果这个命令执行失败了|| 那么就执行这个命令”。</p>

<p>这里有一个使用||的简单例子：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>cp wopper.txt wopper.bak <span class="o">||</span> <span class="nb">echo</span> “if you are seeing this cp failed”
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cp: wopper.txt: No such file or directory
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="k">if </span>you are seeing this cp failed
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的例子中，拷贝命令没有能够被成功执行，因此||后面的命令被执行。</p>

<p>这里有一个更为实用的例子。我希望从一个审计文件中抽取第1个和第5个域，并将其输出到一个临时文件中，如果这一操作未成功，我希望能够收到一个相应邮件：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk ‘<span class="o">{</span>print <span class="nv">$5</span><span class="o">}</span>’ acc.qtr &gt; qtr.tmp <span class="o">||</span> <span class="nb">echo</span> “Sorry the payroll extraction didn’t work” | mail dave
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在这里不只可以使用系统命令；这里我们首先对month_end.txt文件执行了一个名为comet的shell脚本，如果该脚本未执行成功，该shell将结束。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>comet month_end.txt <span class="o">||</span> <span class="nb">exit</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h1>6.3 用（）和{}将命令结合在一起</h1>

<p>如果希望把几个命令合在一起执行， shell提供了两种方法。既可以在当前shell也可以在子shell中执行一组命令。</p>

<p>为了在当前shell中执行一组命令，可以用命令分隔符隔开每一个命令，并把所有的命令用圆括号（）括起来。</p>

<p>它的一般形式为：</p>

<p>（命令1;命令2;. . .）</p>

<p>如果使用{ }来代替（），那么相应的命令将在子shell而不是当前shell中作为一个整体被执行，只有在{ }中所有命令的输出作为一个整体被重定向时，其中的命令才被放到子shell中执行，否则在当前shell执行。它的一般形式为：</p>

<p>{命令1;命令2;. . . }</p>

<p>我很少单独使用这两种方法。我一般只和&amp;&amp;或||一起使用这两种方法。</p>

<p>再回到前面那个comet脚本的例子，如果这个脚本执行失败了，我很可能会希望执行两个以上的命令，而不只是一个命令。我可以使用这两种方法。这是原先那个例子：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>comet month_end.txt <span class="o">||</span> <span class="nb">exit</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>现在如果该脚本执行失败了，我希望先给自己发个邮件，然后再退出，可以用下面的方法来实现：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>comet month_end <span class="o">||</span> <span class="o">(</span><span class="nb">echo</span> “Hello, guess what! Comet did not work”|mail dave;exit<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的例子中，如果只使用了命令分隔符而没有把它们组合在一起，shell将直接执行最后一个命令（exit）。</p>

<p>我们再回头来看看前面那个使用&amp;&amp;排序的例子，下面是原来的那个例子：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sort quarter_end.txt &gt; quarter.sorted &amp;amp;&amp;amp; lp quarter.sorted
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>使用命令组合的方法，如果sort命令执行成功了，可以先将输出文件拷贝到一个日志区，然后再打印。</p>

<h1>6.4 小结</h1>

<p>在编写shell脚本时，使用&amp;&amp;和||对构造判断语句非常有用。如果希望在前一个命令执行失败的情况不执行后面的命令，那么本章所讲述的方法非常简单有效。使用这样的方法，可以根据&amp;&amp;或||前面命令的返回值来控制其后面命令的执行。</p>
]]></content>
  </entry>
  
</feed>
